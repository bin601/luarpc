/*****************************************************************************
* Lua-RPC library, Copyright (C) 2001 Russell L. Smith. All rights reserved. *
*   Email: russ@q12.org   Web: www.q12.org                                   *
* For documentation, see http://www.q12.org/lua. For the license agreement,  *
* see the file LICENSE that comes with this distribution.                    *
*****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <setjmp.h>

#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"

#include "config.h"

/****************************************************************************/
/* parameters */

#define MAXCON 10 /* maximum number of waiting server connections */

/* a kind of silly way to get the maximum int, but oh well ... */
#define MAXINT ((int)((((unsigned int)(-1)) << 1) >> 1))

/****************************************************************************/
/* error handling */

/* allow special handling for GCC compiler */
#ifdef __GNUC__
#define DOGCC(x) x
#else
#define DOGCC(x) /* */
#endif


/* assertions */

#ifndef NDEBUG
#ifdef __GNUC__
#define MYASSERT(a) if (!(a)) debug ( \
  "assertion \"" #a "\" failed in %s() [%s]",__FUNCTION__,__FILE__);
#else
#define MYASSERT(a) if (!(a)) debug ( \
  "assertion \"" #a "\" failed in %s:%d",__FILE__,__LINE__);
#endif
#else
#define MYASSERT(a) ;
#endif


static void errorMessage (const char *msg, va_list ap)
{
  fflush (stdout);
  fflush (stderr);
  fprintf (stderr,"\nError: ");
  vfprintf (stderr,msg,ap);
  fprintf (stderr,"\n\n");
  fflush (stderr);
}


DOGCC(static void panic (const char *msg, ...)
      __attribute__ ((noreturn,unused));)
static void panic (const char *msg, ...)
{
  va_list ap;
  va_start (ap,msg);
  errorMessage (msg,ap);
  exit (1);
}


DOGCC(static void debug (const char *msg, ...)
      __attribute__ ((noreturn,unused));)
static void debug (const char *msg, ...)
{
  va_list ap;
  va_start (ap,msg);
  errorMessage (msg,ap);
  abort();
}



/****************************************************************************/
/* more error handling */

/* error numbers passed around are normal system "errno" error numbers
 * (normally generated by socket operations), except when they have the
 * following values:
 */

enum {
  ERR_EOF      = MAXINT - 100,  /* reached end of file on socket */
  ERR_CLOSED   = MAXINT - 101,  /* attempted operation on closed socket */
  ERR_PROTOCOL = MAXINT - 102 /* some error in the received protocol */
};


/* return a string representation of an error number */

static const char * errorString (int n)
{
  switch (n) {
  case ERR_EOF: return "connection closed unexpectedly (\"end of file\")";
  case ERR_CLOSED: return "operation requested on a closed socket";
  case ERR_PROTOCOL: return "error in the received Lua-RPC protocol";
  default: return sock_strerror (n);
  }
}

/****************************************************************************/
/* exception handling using setjmp()/longjmp().
 *
 * do this:
 *
 *  TRY {
 *    some_stuff();
 *    THROW (error_code);
 *    // if THROW is not called, you must call ENDTRY before the end of
 *    // the TRY block (this includes before any `return' is called).
 *    ENDTRY;
 *  }
 *  CATCH {
 *    // *all* errors caught here, not just specific ones
 *    there_is_an_error (ERRCODE);
 *    if (dont_handle_here()) THROW (ERRCODE);
 *  }
 */

/* the exception stack. the top of the stack is the environment to longjmp()
 * to if there is a THROW.
 */

#define MAX_NESTED_TRYS 4

static jmp_buf exception_stack[MAX_NESTED_TRYS];
volatile static int exception_num_trys = 0;
volatile static int exception_errnum = 0;


/* you can call this when you have just entered or are about to leave a
 * Lua-RPC function from lua itself - this function resets the exception
 * stack, which is not used at all outside Lua-RPC.
 */

static void exception_init()
{
  exception_num_trys = 0;
  exception_errnum = 0;
}


/* throw an exception. this will jump to the most recent CATCH block. */

static void exception_throw (int n)
{
  MYASSERT (exception_num_trys > 0);
  exception_errnum = n;
  exception_num_trys--;
  longjmp (exception_stack[exception_num_trys],1);
}


#define THROW(errnum) exception_throw (errnum)

#define ERRCODE (exception_errnum)

#define TRY \
  MYASSERT (exception_num_trys < MAX_NESTED_TRYS); \
  exception_num_trys++; \
  if (setjmp (exception_stack[exception_num_trys-1]) == 0)

#define ENDTRY { \
  MYASSERT (exception_num_trys > 0); \
  exception_num_trys--; \
}

#define CATCH else


/****************************************************************************/
/* lua utility */

/* replacement for lua_error that resets the exception stack before leaving
 * Lua-RPC.
 */

void my_lua_error (lua_State *L, const char *errmsg)
{
  exception_init();
  lua_pushstring(L,errmsg);
  lua_error (L);
}


/* if the stack size is not `desired_n', trigger a lua runtime error. */

static int check_num_args (lua_State *L, int desired_n)
{
  int n = lua_gettop (L);   /* number of arguments on stack */
  if (n != desired_n) {
    char s[100];
    sprintf (s,"must have %d argument%c",desired_n,
       (desired_n == 1) ? '\0' : 's');
    my_lua_error (L,s);
  }
  return n;
}

static int ismetatable_type (lua_State *L, int ud, const char *tname)
{
  if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
    lua_getfield(L, LUA_REGISTRYINDEX, tname);  /* get correct metatable */
    if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */
      lua_pop(L, 2);  /* remove both metatables */
      return 1;
    }
  }
  return 0;
}

/* check that a given stack value is a port number, and return its value. */

static int get_port_number (lua_State *L, int i)
{
  double port_d;
  int port;
  if (!lua_isnumber (L,i)) my_lua_error (L,"port number argument is bad");
  port_d = lua_tonumber (L,i);
  if (port_d < 0 || port_d > 0xffff)
    my_lua_error (L,"port number must be in the range 0..65535");
  port = (int) port_d;
  if (port_d != port) my_lua_error (L,"port number must be an integer");
  return port;
}

/****************************************************************************/
/* read and write lua variables to a socket.
 * these functions do little error handling of their own, but they call socket
 * functions which may throw exceptions, so calls to these functions must be
 * wrapped in a TRY block.
 */

enum {
  RPC_NIL=0,
  RPC_NUMBER,
  RPC_BOOLEAN,
  RPC_STRING,
  RPC_TABLE,
  RPC_TABLE_END,
  RPC_FUNCTION,
  RPC_FUNCTION_END,
};

enum { RPC_PROTOCOL_VERSION = 3 };


/* prototypes */
static void write_variable (Socket *sock, lua_State *L, int var_index);
static int read_variable (Socket *sock, lua_State *L);


/* write a table at the given index in the stack. the index must be absolute
 * (i.e. positive).
 */

static void write_table (Socket *sock, lua_State *L, int table_index)
{
  lua_pushnil (L);  /* push first key */
  while (lua_next (L,table_index)) {
    /* next key and value were pushed on the stack */
    write_variable (sock,L,lua_gettop (L)-1);
    write_variable (sock,L,lua_gettop (L));
    /* remove value, keep key for next iteration */
    lua_pop (L,1);
  }
}
/* STARTING POINT FOR SENDING FUNCTIONS OVER THE WIRE
static int function_writer (lua_State *L, const void* b, size_t size, void* B) {
  (void)L;
  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
  return 0;
}


static void str_dump (lua_State *L) {
  luaL_Buffer b;
  luaL_checktype(L, 1, LUA_TFUNCTION);
  lua_settop(L, 1);
  luaL_buffinit(L,&b);
  if (lua_dump(L, function_writer, &b) != 0)
    luaL_error(L, "unable to dump given function");
  luaL_pushresult(&b);
  return 1;
}


static void write_function (Socket *sock, lua_State *L, int table_index)
{
  luaL_Buffer b;
  luaL_checktype(L, table_index, LUA_TFUNCTION);
  lua_settop(L, table_index);
  luaL_buffinit(L,&b);
  if (lua_dump(L, function_writer, &b) != 0)
    luaL_error(L, "unable to dump given function");
  //int lua_dump (lua_State *L, lua_Writer writer, void *data);
}
*/

/* write a variable at the given index in the stack. the index must be absolute
 * (i.e. positive).
 */

static void write_variable (Socket *sock, lua_State *L, int var_index)
{
  int stack_at_start = lua_gettop (L);

  switch (lua_type (L,var_index)) {
  case LUA_TNUMBER:
    socket_write_u8 (sock,RPC_NUMBER);
    socket_write_double (sock,lua_tonumber (L,var_index));
    break;

  case LUA_TSTRING: {
    const char *s;
    u32 len;
    socket_write_u8 (sock,RPC_STRING);
    s = lua_tostring (L,var_index);
    len = lua_strlen (L,var_index);
    socket_write_u32 (sock,len);
    socket_write_string (sock,s,len);
    break;
  }

  case LUA_TTABLE:
    socket_write_u8 (sock,RPC_TABLE);
    write_table (sock,L,var_index);
    socket_write_u8 (sock,RPC_TABLE_END);
    break;

  case LUA_TNIL:
    socket_write_u8 (sock,RPC_NIL);
    break;

  case LUA_TBOOLEAN:
    socket_write_u8 (sock,RPC_BOOLEAN);
    socket_write_u8 (sock, ( u8 )lua_toboolean(L, var_index));
    break;

  case LUA_TFUNCTION:
 /* socket_write_u8 (sock,RPC_FUNCTION);
    write_function (sock,L,var_index);
    socket_write_u8 (sock,RPC_FUNCTION_END); */
    my_lua_error (L,"can't pass functions to a remote function");
    break;

  case LUA_TUSERDATA:
    my_lua_error (L,"can't pass user data to a remote function");
    break;

  case LUA_TTHREAD:
    my_lua_error (L,"can't pass threads to a remote function");
    break;

  case LUA_TLIGHTUSERDATA:
    my_lua_error (L,"can't pass light user data to a remote function");
    break;
  }

  MYASSERT (lua_gettop (L) == stack_at_start);
}


/* read a table and push in onto the stack */

static void read_table (Socket *sock, lua_State *L)
{
  int table_index;
  lua_newtable (L);
  table_index = lua_gettop (L);
  for (;;) {
    if (!read_variable (sock,L)) return;
    read_variable (sock,L);
    lua_rawset (L,table_index);
  }
}


/* read a variable and push in onto the stack. this returns 1 if a "normal"
 * variable was read, or 0 if an end-table marker was read (in which case
 * nothing is pushed onto the stack).
 */

static int read_variable (Socket *sock, lua_State *L)
{
  u8 type = socket_read_u8 (sock);

  switch (type) {

  case RPC_NIL:
    lua_pushnil (L);
    break;

  case RPC_BOOLEAN:
    lua_pushboolean (L,socket_read_u8 (sock));
    break;

  case RPC_NUMBER:
    lua_pushnumber (L,socket_read_double (sock));
    break;

  case RPC_STRING: {
    u32 len = socket_read_u32 (sock);
    char *s = (char*) alloca (len+1);
    socket_read_string (sock,s,len);
    s[len] = 0;
    lua_pushlstring (L,s,len);
    break;
  }

  case RPC_TABLE:
    read_table (sock,L);
    break;

  case RPC_TABLE_END:
    return 0;

  default:
    THROW (ERR_PROTOCOL); /* unknown type in request */
  }
  return 1;
}

/****************************************************************************/
/* client side handle and handle helper userdata objects.
 *
 * a handle userdata (handle to a RPC server) is a pointer to a Handle object.
 * a helper userdata is a pointer to a Helper object.
 *
 * helpers let us make expressions like:
 *    handle.funcname (a,b,c)
 * "handle.funcname" returns the helper object, which calls the remote
 * function.
 */

/* global error handling */
static int global_error_handler = LUA_NOREF;  /* function reference */


struct _Handle {
  int refcount;     /* delete the object when this goes to 0 */
  Socket sock;      /* the handle socket */
  int error_handler;    /* function reference */
  int async;      /* nonzero if async mode being used */
  int read_reply_count;   /* number of async call return values to read */
};
typedef struct _Handle Handle;


#define NUM_FUNCNAME_CHARS 4

struct _Helper {
  Handle *handle;     /* pointer to handle object */
  char funcname[NUM_FUNCNAME_CHARS];  /* name of the function */
};
typedef struct _Helper Helper; 


/* handle a client or server side error. NOTE: this function may or may not
 * return. the handle `h' may be 0.
 */

static void deal_with_error (lua_State *L, Handle *h, const char *error_string)
{ 
  if (global_error_handler !=  LUA_NOREF) {
    lua_getref (L,global_error_handler);
    lua_pushstring (L,error_string);
    lua_pcall (L,1,0,0);
  }
  else {
    my_lua_error (L,error_string);
  }
}


static Handle * handle_create (lua_State *L)
{
  Handle *h = (Handle *)lua_newuserdata(L, sizeof(Handle));
  luaL_getmetatable(L, "rpc.handle");
  lua_setmetatable(L, -2);
  h->refcount = 1;
  socket_open (&h->sock);
  h->error_handler = LUA_NOREF;
  h->async = 0;
  h->read_reply_count = 0;
  return h;
}


static void handle_ref (Handle *h)
{
  h->refcount++;
}


static void handle_deref (lua_State *L, Handle *h)
{
  h->refcount--;
  if (h->refcount <= 0) {
    socket_close (&h->sock);
    if (h->error_handler != LUA_NOREF) lua_unref (L,h->error_handler);
    free (h);
  }
}


static Helper * helper_create (lua_State *L, Handle *handle, const char *funcname)
{
  Helper *h = (Helper *)lua_newuserdata(L, sizeof (Helper) - NUM_FUNCNAME_CHARS + strlen(funcname) + 1);
  luaL_getmetatable(L, "rpc.helper");
  lua_setmetatable(L, -2);
  h->handle = handle;
  handle_ref (h->handle);
  strcpy (h->funcname,funcname);
  return h;
}


static void helper_destroy (lua_State *L, Helper *h)
{
  handle_deref (L,h->handle);
  free (h);
}


/* indexing a handle returns a helper */
static int handle_index (lua_State *L)
{
  const char *s;
  Helper *h;

  MYASSERT (lua_gettop (L) == 2);
  MYASSERT (lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.handle"));
  if (lua_type (L,2) != LUA_TSTRING)
    my_lua_error (L,"can't index a handle with a non-string");

  /* make a new helper object */
  s = lua_tostring (L,2);
  h = helper_create (L,(Handle*) lua_touserdata (L,1), s);

  /* return the helper object */
  return 1;
}


/* garbage collection for handles */

static int handle_gc (lua_State *L)
{
  MYASSERT (lua_gettop (L) == 1);
  MYASSERT (lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.handle"));
  handle_deref (L,(Handle*) lua_touserdata (L,1));
  return 0;
}

static int helper_function (lua_State *L)
{
  Helper *h;
  Socket *sock;
  MYASSERT (lua_gettop (L) >= 1);
  MYASSERT (lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.helper"));
  exception_init();
  
  /* get helper object and its socket */
  h = (Helper*) lua_touserdata (L,1);
  sock = &h->handle->sock;

  TRY {
    int i,len,n;
    u32 nret,ret_code;

    /* first read out any pending return values for old async calls */
    for (; h->handle->read_reply_count > 0; h->handle->read_reply_count--) {
      ret_code = socket_read_u8 (sock);   /* return code */
      if (ret_code==0) {
  /* read return arguments, ignore everything we read */
  nret = socket_read_u32 (sock);
  for (i=0; i < ((int) nret); i++) read_variable (sock,L);
  lua_pop (L,nret);
      }
      else {
  /* read error and handle it */
  u32 code = socket_read_u32 (sock);
  u32 len = socket_read_u32 (sock);
  char *err_string = (char*) alloca (len+1);
  socket_read_string (sock,err_string,len);
  err_string[len] = 0;
  ENDTRY;
  deal_with_error (L,h->handle,err_string);
  return 0;
      }
    }

    /* write function name */
    len = strlen (h->funcname);
    socket_write_u32 (sock,len);
    socket_write_string (sock,h->funcname,len);

    /* write number of arguments */
    n = lua_gettop (L);
    socket_write_u32 (sock,n-1);
    
    /* write each argument */
    for (i=2; i<=n; i++) write_variable (sock,L,i);

    /* if we're in async mode, we're done */
    if (h->handle->async) {
      h->handle->read_reply_count++;
      ENDTRY;
      return 0;
    }

    /* read return code */
    ret_code = socket_read_u8 (sock);

    if (ret_code==0) {
      /* read return arguments */
      nret = socket_read_u32 (sock);
      for (i=0; i < ((int) nret); i++) read_variable (sock,L);
      ENDTRY;
      return nret;
    }
    else {
      /* read error and handle it */
      u32 code = socket_read_u32 (sock);
      u32 len = socket_read_u32 (sock);
      char *err_string = (char*) alloca (len+1);
      socket_read_string (sock,err_string,len);
      err_string[len] = 0;
      ENDTRY;
      /* WTF: we're getting no error here!!! */
      deal_with_error (L,h->handle,err_string);
      return 0;
    }
  }
  CATCH {
    if (ERRCODE == ERR_CLOSED) {
      my_lua_error (L,"can't refer to a remote function after the handle has "
        "been closed");
    }
    else {
      deal_with_error (L, h->handle, errorString (ERRCODE));
      socket_close (sock);
    }
    return 0;
  }
}


/* garbage collection for helpers */

static int helper_gc (lua_State *L)
{
  MYASSERT (lua_gettop (L) == 1);
  MYASSERT (lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.helper"));
  helper_destroy (L,(Helper*) lua_touserdata (L,1));
  return 0;
}

/****************************************************************************/
/* server side handle userdata objects. */

struct _ServerHandle {
  Socket lsock;   /* listening socket, always valid if no error */
  Socket asock;   /* accepting socket, valid if connection established */
};
typedef struct _ServerHandle ServerHandle;


static ServerHandle * server_handle_create(lua_State *L)
{
  ServerHandle *h = (ServerHandle *)lua_newuserdata(L, sizeof(ServerHandle));
  luaL_getmetatable(L, "rpc.server_handle");
  lua_setmetatable(L, -2);
  socket_init (&h->lsock);
  socket_init (&h->asock);
  return h;
}


static void server_handle_shutdown (ServerHandle *h)
{
  socket_close (&h->lsock);
  socket_close (&h->asock);
}


static void server_handle_destroy (ServerHandle *h)
{
  server_handle_shutdown (h);
  free (h);
}

/****************************************************************************/
/* remote function calling (client side) */

/* RPC_open (ip_address, port)
 *     returns a handle to the new connection, or nil if there was an error.
 *     if there is an RPC error function defined, it will be called on error.
 */

static int RPC_open (lua_State *L)
{
  Handle *handle=0;
  
  exception_init();
  TRY {
    int ip_port;
    u32 ip_address;
    struct hostent *host;
    char header[5];

    check_num_args (L,2);
    if (!lua_isstring (L,1))
      my_lua_error (L,"first argument must be an ip address string");
    ip_port = get_port_number (L,2);

    host = gethostbyname (lua_tostring (L,1));
    if (!host) {
      deal_with_error (L,0,"could not resolve internet address");
      lua_pushnil (L);
      ENDTRY;
      return 1;
    }

    if (host->h_addrtype != AF_INET || host->h_length != 4) {
      deal_with_error (L,0,"not an internet IPv4 address");
      lua_pushnil (L);
      ENDTRY;
      return 1;
    }
    ip_address = ntohl ( *((u32*)host->h_addr_list[0]) );

    /* make handle */
    handle = handle_create(L);

    /* connect the socket to the target server */
    socket_connect (&handle->sock,ip_address,(u16) ip_port);

    /* write the protocol header */
    header[0] = 'L';
    header[1] = 'R';
    header[2] = 'P';
    header[3] = 'C';
    header[4] = RPC_PROTOCOL_VERSION;
    socket_write_string (&handle->sock,header,sizeof(header));
    
    ENDTRY;
    return 1;
  }
  CATCH {
    if (handle) handle_deref (L,handle);
    deal_with_error (L, 0, errorString (ERRCODE));
    lua_pushnil (L);
    return 1;
  }
}


/* RPC_close (handle)
 *     this closes the socket, but does not free the handle object. that's
 *     because the handle will still be in the user's name space and might be
 *     referred to again. we'll let garbage collection free the object.
 *     it's a lua runtime error to refer to a socket after it has been closed.
 */

static int RPC_close (lua_State *L)
{
  check_num_args (L,1);

  if (lua_isuserdata (L,1)) {
    if (ismetatable_type(L, 1, "rpc.handle")) {
      Handle *handle = (Handle*) lua_touserdata (L,1);
      socket_close (&handle->sock);
      return 0;
    }
    if (ismetatable_type(L, 1, "rpc.server_handle")) {
      ServerHandle *handle = (ServerHandle*) lua_touserdata (L,1);
      server_handle_shutdown (handle);
      return 0;
    }
  }

  my_lua_error (L,"argument must be an RPC handle");
  return 0;
}



/* RPC_async (handle,)
 *     this sets a handle's asynchronous calling mode (0/nil=off, other=on).
 *     (this is for the client only).
 */

static int RPC_async (lua_State *L)
{
  Handle *handle;
  check_num_args (L,2);

  if (!lua_isuserdata (L,1) || !ismetatable_type(L, 1, "rpc.handle"))
    my_lua_error (L,"first argument must be an RPC client handle");
  handle = (Handle*) lua_touserdata (L,1);
  if (lua_isnil (L,2) || (lua_isnumber (L,2) && lua_tonumber (L,2) == 0))
    handle->async = 0;
  else
    handle->async = 1;

  return 0;
}

/****************************************************************************/
/* lua remote function server */

/* a temporary replacement for the _ERRORMESSAGE function, used to catch
 * server side lua errors.
 */

static char tmp_errormessage_buffer[200];

static int server_err_handler (lua_State *L)
{
  if (lua_gettop (L) >= 1) {
    strncpy (tmp_errormessage_buffer, lua_tostring (L,1),
       sizeof (tmp_errormessage_buffer));
    tmp_errormessage_buffer [sizeof (tmp_errormessage_buffer)-1] = 0;
  }
  return 0;
}


/* read function call data and execute the function. this function empties the
 * stack on entry and exit. this redefines _ERRORMESSAGE to catch errors around
 * the function call.
 */

static void read_function_call (Socket *sock, lua_State *L)
{
  int i,stackpos,good_function,nargs;
  u32 len;
  char *funcname;

  /* read function name */
  len = socket_read_u32 (sock); /* function name string length */ 
  funcname = (char*) alloca (len+1);
  socket_read_string (sock,funcname,len);
  funcname[len] = 0;

  /* push error handler for pcall onto stack */
  lua_pushcfunction (L,server_err_handler);

  /* get function */
  stackpos = lua_gettop (L);
  lua_getglobal (L,funcname);
  good_function = lua_isfunction (L,-1);

  /* read number of arguments */
  nargs = socket_read_u32 (sock);

  /* read in each argument, leave it on the stack */
  for (i=0; i<nargs; i++) read_variable (sock,L);

  /* call the function */
  if (good_function) {
    int nret,error_code;
    tmp_errormessage_buffer[0] = 0;

    error_code = lua_pcall (L,nargs,LUA_MULTRET, stackpos);

    /* handle errors */
    if (error_code || tmp_errormessage_buffer[0]) {
      int len = strlen (tmp_errormessage_buffer);
      socket_write_u8 (sock,1);
      socket_write_u32 (sock,error_code);
      socket_write_u32 (sock,len);
      socket_write_string (sock,tmp_errormessage_buffer,len);
    }
    else {
      /* pass the return values back to the caller */
      socket_write_u8 (sock,0);
      nret = lua_gettop (L) - stackpos;
      socket_write_u32 (sock,nret);
      for (i=0; i<nret; i++) write_variable (sock,L,stackpos+1+i);
    }
  }
  else {
    /* bad function */
    const char *msg = "undefined function: ";
    int errlen = strlen (msg) + len;
    socket_write_u8 (sock,1);
    socket_write_u32 (sock,LUA_ERRRUN);
    socket_write_u32 (sock,errlen);
    socket_write_string (sock,msg,strlen(msg));
    socket_write_string (sock,funcname,len);
  }

  /* empty the stack */
  lua_settop (L,0);
}


static ServerHandle *RPC_listen_helper (lua_State *L)
{
  ServerHandle *handle = 0;
  exception_init();

  TRY {
    int port;

    check_num_args (L,1);
    port = get_port_number (L,1);

    /* make server handle */
    handle = server_handle_create(L);

    /* make listening socket */
    socket_open (&handle->lsock);
    socket_bind (&handle->lsock,INADDR_ANY,(u16) port);
    socket_listen (&handle->lsock,MAXCON);
    
    ENDTRY;
    return handle;
  }
  CATCH {
    if (handle) server_handle_destroy (handle);
    deal_with_error (L, 0, errorString (ERRCODE));
    return 0;
  }
}


/* RPC_listen (port) --> server_handle */

static int RPC_listen (lua_State *L)
{
  ServerHandle *handle;
  handle = RPC_listen_helper (L);
  return 1;
}


/* RPC_peek (server_handle) --> 0 or 1 */

static int RPC_peek (lua_State *L)
{
  ServerHandle *handle;
  check_num_args (L,1);
  if (!(lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.server_handle")))
    my_lua_error (L,"argument must be an RPC server handle");

  handle = (ServerHandle*) lua_touserdata (L,1);

  /* if accepting socket is open, see if there is any data to read */
  if (socket_is_open (&handle->asock)) {
    if (socket_readable (&handle->asock)) lua_pushnumber (L,1);
    else lua_pushnil (L);
    return 1;
  }

  /* otherwise, see if there is a new connection on the listening socket */
  if (socket_is_open (&handle->lsock)) {
    if (socket_readable (&handle->lsock)) lua_pushnumber (L,1);
    else lua_pushnil (L);
    return 1;
  }

  lua_pushnumber (L,0);
  return 1;
}


static void RPC_dispatch_helper (lua_State *L, ServerHandle *handle)
{
  exception_init();
  TRY {
    /* if accepting socket is open, read function calls */
    if (socket_is_open (&handle->asock)) {
      TRY {
  read_function_call (&handle->asock,L);
  ENDTRY;
      }
      CATCH {
  /* if the client has closed the connection, close our side
   * gracefully too.
   */
  socket_close (&handle->asock);
  if (ERRCODE != ERR_EOF && ERRCODE != ERR_PROTOCOL) THROW (ERRCODE);
      }
    }
    else {
      /* if accepting socket is not open, accept a new connection from the
       * listening socket.
       */
      char header[5];
      socket_accept (&handle->lsock, &handle->asock);

      /* check that the header is ok */
      socket_read_string (&handle->asock,header,sizeof(header));
      if (header[0] != 'L' ||
    header[1] != 'R' ||
    header[2] != 'P' ||
    header[3] != 'C' ||
    header[4] != RPC_PROTOCOL_VERSION) {
  /* bad remote function call header, close the connection */
  socket_close (&handle->asock);
  ENDTRY;
  return;
      }
    }

    ENDTRY;
  }
  CATCH {
    server_handle_shutdown (handle);
    deal_with_error (L, 0, errorString (ERRCODE));
  }
}


/* RPC_dispatch (server_handle) */

static int RPC_dispatch (lua_State *L)
{
  ServerHandle *handle;
  check_num_args (L,1);
  if (!(lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.server_handle")))
    my_lua_error (L,"argument must be an RPC server handle");
  handle = (ServerHandle*) lua_touserdata (L,1);

  RPC_dispatch_helper (L,handle);
  return 0;
}


/* lrf_server (port) */

static int RPC_server (lua_State *L)
{
  ServerHandle *handle = RPC_listen_helper (L);
  while (socket_is_open (&handle->lsock)) {
    RPC_dispatch_helper (L,handle);
  }
  server_handle_destroy (handle);
  return 0;
}


/* garbage collection for server handles */

static int server_handle_gc (lua_State *L)
{
  MYASSERT (lua_gettop (L) == 1);
  MYASSERT (lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.server_handle"));
  server_handle_destroy ((ServerHandle*) lua_touserdata (L,1));
  return 0;
}

/****************************************************************************/
/* more error handling stuff */

/* RPC_on_error ([handle,] error_handler)
 */

static int RPC_on_error (lua_State *L)
{
  check_num_args (L,1);

  if (global_error_handler !=  LUA_NOREF) lua_unref (L,global_error_handler);
  global_error_handler = LUA_NOREF;

  if (lua_isfunction (L,1)) {
    global_error_handler = lua_ref (L,1);
  }
  else if (lua_isnil (L,1)) {
  }
  else my_lua_error (L,"bad arguments");

  /* @@@ add option for handle */
  /* Handle *h = (Handle*) lua_touserdata (L,1); */
  /* if (lua_isuserdata (L,1) && ismetatable_type(L, 1, "rpc.handle")); */

  return 0;
}

/****************************************************************************/
/* register RPC functions */

/* debugging function */

static int garbage_collect (lua_State *L)
{
  lua_gc (L,LUA_GCCOLLECT,0);
  return 0;
}

static const luaL_reg rpc_handle[] =
{
  { "__index",  handle_index },
  { NULL,   NULL    }
};

static const luaL_reg rpc_helper[] =
{
  { "__call", helper_function   },
  { NULL,   NULL    }
};

static const luaL_reg rpc_server_handle[] =
{
  { NULL,   NULL    }
};


LUALIB_API int luaopen_luarpc(lua_State *L)
{
  static int started = 0;
  if (started) panic ("luaopen_rpc() called more than once");
  started = 1;

  net_startup();
  lua_register (L,"RPC_open",RPC_open);
  lua_register (L,"RPC_close",RPC_close);
  lua_register (L,"RPC_server",RPC_server);
  lua_register (L,"RPC_on_error",RPC_on_error);
  lua_register (L,"RPC_listen",RPC_listen);
  lua_register (L,"RPC_peek",RPC_peek);
  lua_register (L,"RPC_dispatch",RPC_dispatch);
  lua_register (L,"RPC_async",RPC_async);

  luaL_newmetatable(L, "rpc.helper");
  luaL_openlib(L,NULL,rpc_helper,0);
  
  luaL_newmetatable(L, "rpc.handle");
  luaL_openlib(L,NULL,rpc_handle,0);
  
  luaL_newmetatable(L, "rpc.server_handle");
  luaL_openlib(L,NULL,rpc_server_handle,0);

  if (sizeof(double) != 8)
    debug ("internal error: sizeof(double) != 8");

  return 1;
}
